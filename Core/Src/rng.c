/**
 ******************************************************************************
 * @file           : rng.c
 * @author         : Dr. Joshua Butler
 * @date           : Dec 9, 2024
 * @brief          : Random number generator for selecting the next tetrimino
 ******************************************************************************
 * @attention
 *
 * 2025 Imagine RIT Project: Classic Tetris on LED Grid
 *
 * Copyright (c) 2024-25 Rochester Institute of Technology.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/**
 ********************************************************************************
 * Use the algorithm given in the https://meatfighter.com/nintendotetrisai/ article
 *
 * Each successive pseudorandom number is generated by treating the value as a
 * 17-bit number and setting the highest bit to the result of XORing bits 1 and 9
 * together. Then, the value is right shifted, tossing away the lowest bit.
 *
 * It uses Linear Feedback Shift Register (LFSR) algorithm to generate random numbers.
 *
 * The algorithm gives balanced choices for the next tetrimino.
 */

#include <stdint.h>
#include "rng.h"
#include "main.h"

volatile static uint16_t rng_seed = 0;

/**
 * @brief  Initialize random number generator
 * @param  seeding value
 * @retval None
 */
void rng_init(uint16_t seed) {
    // Initialize random number generator
    if (seed == 0) {
        seed = (uint16_t) TIM2->CNT & 0xFFFF;
    }
    rng_seed = seed;
}

/**
 * @brief  Compute the next random number
 * @param  None
 * @retval next chosen 16-bit random number
 */
uint16_t rng_next(void) {
    // Compute the next random number using LFSR algorithm from the seeding value
    uint16_t new_seed = rng_seed;

    // XOR bits 1 and 9
    uint16_t bit1 = (rng_seed >> 1) & 0x01;
    uint16_t bit9 = (rng_seed >> 9) & 0x01;
    uint16_t leftmost_bit = bit1 ^ bit9;
    new_seed = (new_seed >> 1) | (leftmost_bit << 15);
    if (!new_seed) {  // Eventually the seed will produce an endless sequence of zeros
        new_seed = 0x8988;
    }
    rng_seed = new_seed;

    return rng_seed;
}
